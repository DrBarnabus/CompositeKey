//HintName: UnitTests.TagKey.g.cs
// <auto-generated />

#nullable enable annotations
#nullable disable warnings

// Suppress warnings about [Obsolete] member usage in generated code.
#pragma warning disable CS0612, CS0618

using System;
using CompositeKey;

namespace UnitTests
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("CompositeKey.SourceGeneration", "VERSION")]
    public partial record TagKey : IPrimaryKey<TagKey>
    {
        public override string ToString()
        {
            if (Tags.Count == 0)
                throw new FormatException("Collection must contain at least one item.");
            
            var handler = new System.Runtime.CompilerServices.DefaultInterpolatedStringHandler(4, 0, global::System.Globalization.CultureInfo.InvariantCulture);
            handler.AppendLiteral("TAG");
            handler.AppendLiteral("_");
            for (int i = 0; i < Tags.Count; i++)
            {
                if (i > 0)
                    handler.AppendLiteral("#");
                
                handler.AppendFormatted(Tags[i]);
            }

            return handler.ToStringAndClear();
        }

        public string ToPartitionKeyString()
        {
            if (Tags.Count == 0)
                throw new FormatException("Collection must contain at least one item.");
            
            var handler = new System.Runtime.CompilerServices.DefaultInterpolatedStringHandler(4, 0, global::System.Globalization.CultureInfo.InvariantCulture);
            handler.AppendLiteral("TAG");
            handler.AppendLiteral("_");
            for (int i = 0; i < Tags.Count; i++)
            {
                if (i > 0)
                    handler.AppendLiteral("#");
                
                handler.AppendFormatted(Tags[i]);
            }

            return handler.ToStringAndClear();
        }

        public string ToPartitionKeyString(int throughPartIndex, bool includeTrailingDelimiter = true)
        {
            switch (throughPartIndex, includeTrailingDelimiter)
            {
                case (0, false): return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"TAG");
                case (0, true): return string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"TAG_");
            }

            int fixedPartCount = 1;
            int repeatIndex = throughPartIndex - fixedPartCount;
            int repeatCount = Math.Min(repeatIndex + 1, Tags.Count);
            if (repeatCount <= 0)
                throw new InvalidOperationException("Invalid throughPartIndex for repeating section.");
            
            var handler = new System.Runtime.CompilerServices.DefaultInterpolatedStringHandler(0, 0, global::System.Globalization.CultureInfo.InvariantCulture);
            handler.AppendFormatted(string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"TAG_"));

            for (int i = 0; i < repeatCount; i++)
            {
                if (i > 0)
                {
                    handler.AppendLiteral("#");
                }

                handler.AppendFormatted(Tags[i]);
            }

            if (includeTrailingDelimiter)
            {
                handler.AppendLiteral("#");
            }

            return handler.ToStringAndClear();
        }

        public static TagKey Parse(string primaryKey)
        {
            ArgumentNullException.ThrowIfNull(primaryKey);
        
            return Parse((ReadOnlySpan<char>)primaryKey);
        }
        
        public static TagKey Parse(ReadOnlySpan<char> primaryKey)
        {
            if (primaryKey.Length < 5)
                throw new FormatException("Unrecognized format.");
            
            const int expectedPrimaryKeyParts = 2;
            Span<Range> primaryKeyPartRanges = stackalloc Range[expectedPrimaryKeyParts + 1];
            if (primaryKey.Split(primaryKeyPartRanges, '_', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPrimaryKeyParts)
                throw new FormatException("Unrecognized format.");
            
            if (!primaryKey[primaryKeyPartRanges[0]].Equals("TAG", StringComparison.Ordinal))
                throw new FormatException("Unrecognized format.");
            
            Span<Range> tagsRanges = stackalloc Range[128];
            int tagsCount = primaryKey[primaryKeyPartRanges[1]].Split(tagsRanges, '#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            if (tagsCount < 1)
                throw new FormatException("Unrecognized format.");
            
            var tags = new global::System.Collections.Generic.List<string>();
            for (int ri = 0; ri < tagsCount; ri++)
            {
                if (primaryKey[primaryKeyPartRanges[1]][tagsRanges[ri]].Length == 0)
                    throw new FormatException("Unrecognized format.");
                tags.Add(primaryKey[primaryKeyPartRanges[1]][tagsRanges[ri]].ToString());
            }

            if (tags.Count == 0)
                throw new FormatException("Unrecognized format.");
            
            return new TagKey() { Tags = tags };
        }

        public static bool TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string? primaryKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out TagKey? result)
        {
            if (primaryKey is null)
            {
                result = null;
                return false;
            }
        
            return TryParse((ReadOnlySpan<char>)primaryKey, out result);
        }
        
        public static bool TryParse(ReadOnlySpan<char> primaryKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out TagKey? result)
        {
            result = null;
        
            if (primaryKey.Length < 5)
                return false;
            
            const int expectedPrimaryKeyParts = 2;
            Span<Range> primaryKeyPartRanges = stackalloc Range[expectedPrimaryKeyParts + 1];
            if (primaryKey.Split(primaryKeyPartRanges, '_', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPrimaryKeyParts)
                return false;
            
            if (!primaryKey[primaryKeyPartRanges[0]].Equals("TAG", StringComparison.Ordinal))
                return false;
            
            Span<Range> tagsRanges = stackalloc Range[128];
            int tagsCount = primaryKey[primaryKeyPartRanges[1]].Split(tagsRanges, '#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            if (tagsCount < 1)
                return false;
            
            var tags = new global::System.Collections.Generic.List<string>();
            for (int ri = 0; ri < tagsCount; ri++)
            {
                if (primaryKey[primaryKeyPartRanges[1]][tagsRanges[ri]].Length == 0)
                    return false;
                tags.Add(primaryKey[primaryKeyPartRanges[1]][tagsRanges[ri]].ToString());
            }

            if (tags.Count == 0)
                return false;
            
            result = new TagKey() { Tags = tags };
            return true;
        }

        /// <inheritdoc cref="IFormattable.ToString(string?, IFormatProvider?)" />
        string IFormattable.ToString(string? format, IFormatProvider? formatProvider) => ToString();
        
        /// <inheritdoc cref="IParsable{TagKey}.Parse(string, IFormatProvider?)" />
        static TagKey IParsable<TagKey>.Parse(string s, IFormatProvider? provider) => Parse(s);
        
        /// <inheritdoc cref="IParsable{TagKey}.TryParse(string?, IFormatProvider?, out TagKey)" />
        static bool IParsable<TagKey>.TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string? s, IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out TagKey result) => TryParse(s, out result);
        
        /// <inheritdoc cref="ISpanParsable{TagKey}.Parse(ReadOnlySpan{char}, IFormatProvider?)" />
        static TagKey ISpanParsable<TagKey>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => Parse(s);
        
        /// <inheritdoc cref="ISpanParsable{TagKey}.TryParse(ReadOnlySpan{char}, IFormatProvider?, out TagKey)" />
        static bool ISpanParsable<TagKey>.TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out TagKey result) => TryParse(s, out result);
    }
}
