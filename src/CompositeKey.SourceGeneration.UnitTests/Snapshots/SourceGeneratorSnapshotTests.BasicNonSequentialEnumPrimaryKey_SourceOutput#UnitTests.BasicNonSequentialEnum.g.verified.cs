//HintName: UnitTests.BasicNonSequentialEnum.g.cs
// <auto-generated />

#nullable enable annotations
#nullable disable warnings

// Suppress warnings about [Obsolete] member usage in generated code.
#pragma warning disable CS0612, CS0618

using System;
using CompositeKey;

namespace UnitTests
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("CompositeKey.SourceGeneration", "VERSION")]
    public partial record BasicNonSequentialEnum : ICompositePrimaryKey<BasicNonSequentialEnum>
    {
        public override string ToString()
        {
            return string.Create(54 + SecondPart.Length + CustomEnumHelper.GetFormattedLength(ThirdPart), this, static (destination, state) =>
            {
                int position = 0;

                {
                    if (!((ISpanFormattable)state.FirstPart).TryFormat(destination[position..], out int firstPartCharsWritten, "b", global::System.Globalization.CultureInfo.InvariantCulture))
                    	throw new FormatException();

                    position += firstPartCharsWritten;
                }

                destination[position] = '#';
                position += 1;

                state.SecondPart.CopyTo(destination[position..]);
                position += state.SecondPart.Length;

                destination[position] = '|';
                position += 1;

                "ConstantValue".CopyTo(destination[position..]);
                position += 13;

                destination[position] = '#';
                position += 1;

                {
                    if (!CustomEnumHelper.TryFormat(state.ThirdPart, destination[position..], out int thirdPartCharsWritten))
                    	throw new FormatException();

                    position += thirdPartCharsWritten;
                }
            });
        }

        public string ToPartitionKeyString()
        {
            return string.Create(39 + SecondPart.Length, this, static (destination, state) =>
            {
                int position = 0;

                {
                    if (!((ISpanFormattable)state.FirstPart).TryFormat(destination[position..], out int firstPartCharsWritten, "b", global::System.Globalization.CultureInfo.InvariantCulture))
                    	throw new FormatException();

                    position += firstPartCharsWritten;
                }

                destination[position] = '#';
                position += 1;

                state.SecondPart.CopyTo(destination[position..]);
                position += state.SecondPart.Length;
            });
        }

        public string ToPartitionKeyString(int throughPartIndex, bool includeTrailingDelimiter = true)
        {
            return (throughPartIndex, includeTrailingDelimiter) switch
            {
                (0, false) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{FirstPart:b}"),
                (0, true) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{FirstPart:b}#"),
                (1, false) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{FirstPart:b}#{SecondPart}"),
                _ => throw new InvalidOperationException("Invalid combination of throughPartIndex and includeTrailingDelimiter provided")
            };
        }

        public string ToSortKeyString()
        {
            return string.Create(14 + CustomEnumHelper.GetFormattedLength(ThirdPart), this, static (destination, state) =>
            {
                int position = 0;

                "ConstantValue".CopyTo(destination[position..]);
                position += 13;

                destination[position] = '#';
                position += 1;

                {
                    if (!CustomEnumHelper.TryFormat(state.ThirdPart, destination[position..], out int thirdPartCharsWritten))
                    	throw new FormatException();

                    position += thirdPartCharsWritten;
                }
            });
        }

        public string ToSortKeyString(int throughPartIndex, bool includeTrailingDelimiter = true)
        {
            return (throughPartIndex, includeTrailingDelimiter) switch
            {
                (0, false) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"ConstantValue"),
                (0, true) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"ConstantValue#"),
                (1, false) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"ConstantValue#{ThirdPart:g}"),
                _ => throw new InvalidOperationException("Invalid combination of throughPartIndex and includeTrailingDelimiter provided")
            };
        }

        public static BasicNonSequentialEnum Parse(string primaryKey)
        {
            ArgumentNullException.ThrowIfNull(primaryKey);
        
            return Parse((ReadOnlySpan<char>)primaryKey);
        }
        
        public static BasicNonSequentialEnum Parse(ReadOnlySpan<char> primaryKey)
        {
            const int expectedPrimaryKeyParts = 2;
            Span<Range> primaryKeyPartRanges = stackalloc Range[expectedPrimaryKeyParts + 1];
            if (primaryKey.Split(primaryKeyPartRanges, '|', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPrimaryKeyParts)
                throw new FormatException("Unrecognized format.");
            
            return Parse(primaryKey[primaryKeyPartRanges[0]], primaryKey[primaryKeyPartRanges[1]]);
        }

        public static bool TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string? primaryKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicNonSequentialEnum? result)
        {
            if (primaryKey is null)
            {
                result = null;
                return false;
            }
        
            return TryParse((ReadOnlySpan<char>)primaryKey, out result);
        }
        
        public static bool TryParse(ReadOnlySpan<char> primaryKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicNonSequentialEnum? result)
        {
            result = null;
        
            const int expectedPrimaryKeyParts = 2;
            Span<Range> primaryKeyPartRanges = stackalloc Range[expectedPrimaryKeyParts + 1];
            if (primaryKey.Split(primaryKeyPartRanges, '|', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPrimaryKeyParts)
                return false;
            
            return TryParse(primaryKey[primaryKeyPartRanges[0]], primaryKey[primaryKeyPartRanges[1]], out result);
        }

        public static BasicNonSequentialEnum Parse(string partitionKey, string sortKey)
        {
            ArgumentNullException.ThrowIfNull(partitionKey);
            ArgumentNullException.ThrowIfNull(sortKey);
        
            return Parse((ReadOnlySpan<char>)partitionKey, (ReadOnlySpan<char>)sortKey);
        }
        
        public static BasicNonSequentialEnum Parse(ReadOnlySpan<char> partitionKey, ReadOnlySpan<char> sortKey)
        {
            if (partitionKey.Length < 40)
                throw new FormatException("Unrecognized format.");
            
            if (sortKey.Length < 15)
                throw new FormatException("Unrecognized format.");
            
            const int expectedPartitionKeyParts = 2;
            Span<Range> partitionKeyPartRanges = stackalloc Range[expectedPartitionKeyParts + 1];
            if (partitionKey.Split(partitionKeyPartRanges, '#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPartitionKeyParts)
                throw new FormatException("Unrecognized format.");
            
            const int expectedSortKeyParts = 2;
            Span<Range> sortKeyPartRanges = stackalloc Range[expectedSortKeyParts + 1];
            if (sortKey.Split(sortKeyPartRanges, '#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedSortKeyParts)
                throw new FormatException("Unrecognized format.");
            
            if (partitionKey[partitionKeyPartRanges[0]].Length != 38 || !Guid.TryParseExact(partitionKey[partitionKeyPartRanges[0]], "b", out var firstPart))
                throw new FormatException("Unrecognized format.");
            
            if (partitionKey[partitionKeyPartRanges[1]].Length == 0)
                throw new FormatException("Unrecognized format.");
            
            string secondPart = partitionKey[partitionKeyPartRanges[1]].ToString();
            
            if (!sortKey[sortKeyPartRanges[0]].Equals("ConstantValue", StringComparison.Ordinal))
                throw new FormatException("Unrecognized format.");
            
            if (!CustomEnumHelper.TryParse(sortKey[sortKeyPartRanges[1]], out var thirdPart))
                throw new FormatException("Unrecognized format.");
            
            return new BasicNonSequentialEnum(firstPart, secondPart, thirdPart);
        }

        public static bool TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string partitionKey, string sortKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicNonSequentialEnum? result)
        {
            if (partitionKey is null || sortKey is null)
            {
                result = null;
                return false;
            }
        
            return TryParse((ReadOnlySpan<char>)partitionKey, (ReadOnlySpan<char>)sortKey, out result);
        }
        
        public static bool TryParse(ReadOnlySpan<char> partitionKey, ReadOnlySpan<char> sortKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicNonSequentialEnum? result)
        {
            result = null;
        
            if (partitionKey.Length < 40)
                return false;
            
            if (sortKey.Length < 15)
                return false;
            
            const int expectedPartitionKeyParts = 2;
            Span<Range> partitionKeyPartRanges = stackalloc Range[expectedPartitionKeyParts + 1];
            if (partitionKey.Split(partitionKeyPartRanges, '#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPartitionKeyParts)
                return false;
            
            const int expectedSortKeyParts = 2;
            Span<Range> sortKeyPartRanges = stackalloc Range[expectedSortKeyParts + 1];
            if (sortKey.Split(sortKeyPartRanges, '#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedSortKeyParts)
                return false;
            
            if (partitionKey[partitionKeyPartRanges[0]].Length != 38 || !Guid.TryParseExact(partitionKey[partitionKeyPartRanges[0]], "b", out var firstPart))
                return false;
            
            if (partitionKey[partitionKeyPartRanges[1]].Length == 0)
                return false;
            
            string secondPart = partitionKey[partitionKeyPartRanges[1]].ToString();
            
            if (!sortKey[sortKeyPartRanges[0]].Equals("ConstantValue", StringComparison.Ordinal))
                return false;
            
            if (!CustomEnumHelper.TryParse(sortKey[sortKeyPartRanges[1]], out var thirdPart))
                return false;
            
            result = new BasicNonSequentialEnum(firstPart, secondPart, thirdPart);
            return true;
        }

        /// <inheritdoc cref="IFormattable.ToString(string?, IFormatProvider?)" />
        string IFormattable.ToString(string? format, IFormatProvider? formatProvider) => ToString();
        
        /// <inheritdoc cref="IParsable{BasicNonSequentialEnum}.Parse(string, IFormatProvider?)" />
        static BasicNonSequentialEnum IParsable<BasicNonSequentialEnum>.Parse(string s, IFormatProvider? provider) => Parse(s);
        
        /// <inheritdoc cref="IParsable{BasicNonSequentialEnum}.TryParse(string?, IFormatProvider?, out BasicNonSequentialEnum)" />
        static bool IParsable<BasicNonSequentialEnum>.TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string? s, IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicNonSequentialEnum result) => TryParse(s, out result);
        
        /// <inheritdoc cref="ISpanParsable{BasicNonSequentialEnum}.Parse(ReadOnlySpan{char}, IFormatProvider?)" />
        static BasicNonSequentialEnum ISpanParsable<BasicNonSequentialEnum>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => Parse(s);
        
        /// <inheritdoc cref="ISpanParsable{BasicNonSequentialEnum}.TryParse(ReadOnlySpan{char}, IFormatProvider?, out BasicNonSequentialEnum)" />
        static bool ISpanParsable<BasicNonSequentialEnum>.TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicNonSequentialEnum result) => TryParse(s, out result);
    }
    file class CustomEnumHelper
    {
        public static int GetFormattedLength(global::UnitTests.CustomEnum value)
        {
            return value switch
            {
                global::UnitTests.CustomEnum.One => 3,
                global::UnitTests.CustomEnum.Two => 3,
                global::UnitTests.CustomEnum.Three => 5,
                _ => throw new ArgumentOutOfRangeException(nameof(value), value, "The value provided is out of range.")
            };
        }

        public static bool TryFormat(global::UnitTests.CustomEnum value, Span<char> destination, out int charsWritten)
        {
            charsWritten = GetFormattedLength(value);
            if (destination.Length < charsWritten)
                return false;
            
            switch (value)
            {
                case global::UnitTests.CustomEnum.One:
                    "One".CopyTo(destination);
                    return true;
                case global::UnitTests.CustomEnum.Two:
                    "Two".CopyTo(destination);
                    return true;
                case global::UnitTests.CustomEnum.Three:
                    "Three".CopyTo(destination);
                    return true;
                default:
                    charsWritten = 0;
                    return false;
            }
        }

        public static bool TryParse(in ReadOnlySpan<char> value, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::UnitTests.CustomEnum result)
        {
            switch (value)
            {
                case var _ when value.Equals(nameof(global::UnitTests.CustomEnum.One), StringComparison.Ordinal):
                    result = global::UnitTests.CustomEnum.One;
                    return true;
                case var _ when value.Equals(nameof(global::UnitTests.CustomEnum.Two), StringComparison.Ordinal):
                    result = global::UnitTests.CustomEnum.Two;
                    return true;
                case var _ when value.Equals(nameof(global::UnitTests.CustomEnum.Three), StringComparison.Ordinal):
                    result = global::UnitTests.CustomEnum.Three;
                    return true;
                default:
                    result = default;
                    return false;
            }
        }

    }
}
