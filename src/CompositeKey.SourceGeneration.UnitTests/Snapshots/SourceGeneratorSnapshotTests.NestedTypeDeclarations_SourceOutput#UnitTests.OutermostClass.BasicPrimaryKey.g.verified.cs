//HintName: UnitTests.OutermostClass.BasicPrimaryKey.g.cs
// <auto-generated />

#nullable enable annotations
#nullable disable warnings

// Suppress warnings about [Obsolete] member usage in generated code.
#pragma warning disable CS0612, CS0618

using System;
using CompositeKey;

namespace UnitTests
{
    public static partial class OutermostClass
    {
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("CompositeKey.SourceGeneration", "VERSION")]
        public partial record BasicPrimaryKey : IPrimaryKey<BasicPrimaryKey>
        {
            public override string ToString()
            {
                return string.Create(110, this, static (destination, state) =>
                {
                    int position = 0;

                    {
                        if (!((ISpanFormattable)state.FirstPart).TryFormat(destination[position..], out int firstPartCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                        	throw new FormatException();

                        position += firstPartCharsWritten;
                    }

                    destination[position] = '#';
                    position += 1;

                    {
                        if (!((ISpanFormattable)state.SecondPart).TryFormat(destination[position..], out int secondPartCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                        	throw new FormatException();

                        position += secondPartCharsWritten;
                    }

                    destination[position] = '#';
                    position += 1;

                    {
                        if (!((ISpanFormattable)state.ThirdPart).TryFormat(destination[position..], out int thirdPartCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                        	throw new FormatException();

                        position += thirdPartCharsWritten;
                    }
                });
            }

            public string ToPartitionKeyString()
            {
                return string.Create(110, this, static (destination, state) =>
                {
                    int position = 0;

                    {
                        if (!((ISpanFormattable)state.FirstPart).TryFormat(destination[position..], out int firstPartCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                        	throw new FormatException();

                        position += firstPartCharsWritten;
                    }

                    destination[position] = '#';
                    position += 1;

                    {
                        if (!((ISpanFormattable)state.SecondPart).TryFormat(destination[position..], out int secondPartCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                        	throw new FormatException();

                        position += secondPartCharsWritten;
                    }

                    destination[position] = '#';
                    position += 1;

                    {
                        if (!((ISpanFormattable)state.ThirdPart).TryFormat(destination[position..], out int thirdPartCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                        	throw new FormatException();

                        position += thirdPartCharsWritten;
                    }
                });
            }

            public string ToPartitionKeyString(int throughPartIndex, bool includeTrailingDelimiter = true)
            {
                return (throughPartIndex, includeTrailingDelimiter) switch
                {
                    (0, false) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{FirstPart:d}"),
                    (0, true) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{FirstPart:d}#"),
                    (1, false) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{FirstPart:d}#{SecondPart:d}"),
                    (1, true) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{FirstPart:d}#{SecondPart:d}#"),
                    (2, false) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{FirstPart:d}#{SecondPart:d}#{ThirdPart:d}"),
                    _ => throw new InvalidOperationException("Invalid combination of throughPartIndex and includeTrailingDelimiter provided")
                };
            }

            public static BasicPrimaryKey Parse(string primaryKey)
            {
                ArgumentNullException.ThrowIfNull(primaryKey);
            
                return Parse((ReadOnlySpan<char>)primaryKey);
            }
            
            public static BasicPrimaryKey Parse(ReadOnlySpan<char> primaryKey)
            {
                if (primaryKey.Length != 110)
                    throw new FormatException("Unrecognized format.");
                
                const int expectedPrimaryKeyParts = 3;
                Span<Range> primaryKeyPartRanges = stackalloc Range[expectedPrimaryKeyParts + 1];
                if (primaryKey.Split(primaryKeyPartRanges, '#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPrimaryKeyParts)
                    throw new FormatException("Unrecognized format.");
                
                if (primaryKey[primaryKeyPartRanges[0]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[0]], "d", out var firstPart))
                    throw new FormatException("Unrecognized format.");
                
                if (primaryKey[primaryKeyPartRanges[1]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[1]], "d", out var secondPart))
                    throw new FormatException("Unrecognized format.");
                
                if (primaryKey[primaryKeyPartRanges[2]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[2]], "d", out var thirdPart))
                    throw new FormatException("Unrecognized format.");
                
                return new BasicPrimaryKey(firstPart, secondPart, thirdPart);
            }

            public static bool TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string? primaryKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicPrimaryKey? result)
            {
                if (primaryKey is null)
                {
                    result = null;
                    return false;
                }
            
                return TryParse((ReadOnlySpan<char>)primaryKey, out result);
            }
            
            public static bool TryParse(ReadOnlySpan<char> primaryKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicPrimaryKey? result)
            {
                result = null;
            
                if (primaryKey.Length != 110)
                    return false;
                
                const int expectedPrimaryKeyParts = 3;
                Span<Range> primaryKeyPartRanges = stackalloc Range[expectedPrimaryKeyParts + 1];
                if (primaryKey.Split(primaryKeyPartRanges, '#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPrimaryKeyParts)
                    return false;
                
                if (primaryKey[primaryKeyPartRanges[0]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[0]], "d", out var firstPart))
                    return false;
                
                if (primaryKey[primaryKeyPartRanges[1]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[1]], "d", out var secondPart))
                    return false;
                
                if (primaryKey[primaryKeyPartRanges[2]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[2]], "d", out var thirdPart))
                    return false;
                
                result = new BasicPrimaryKey(firstPart, secondPart, thirdPart);
                return true;
            }

            /// <inheritdoc cref="IFormattable.ToString(string?, IFormatProvider?)" />
            string IFormattable.ToString(string? format, IFormatProvider? formatProvider) => ToString();
            
            /// <inheritdoc cref="IParsable{BasicPrimaryKey}.Parse(string, IFormatProvider?)" />
            static BasicPrimaryKey IParsable<BasicPrimaryKey>.Parse(string s, IFormatProvider? provider) => Parse(s);
            
            /// <inheritdoc cref="IParsable{BasicPrimaryKey}.TryParse(string?, IFormatProvider?, out BasicPrimaryKey)" />
            static bool IParsable<BasicPrimaryKey>.TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string? s, IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicPrimaryKey result) => TryParse(s, out result);
            
            /// <inheritdoc cref="ISpanParsable{BasicPrimaryKey}.Parse(ReadOnlySpan{char}, IFormatProvider?)" />
            static BasicPrimaryKey ISpanParsable<BasicPrimaryKey>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => Parse(s);
            
            /// <inheritdoc cref="ISpanParsable{BasicPrimaryKey}.TryParse(ReadOnlySpan{char}, IFormatProvider?, out BasicPrimaryKey)" />
            static bool ISpanParsable<BasicPrimaryKey>.TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out BasicPrimaryKey result) => TryParse(s, out result);
        }
    }
}
