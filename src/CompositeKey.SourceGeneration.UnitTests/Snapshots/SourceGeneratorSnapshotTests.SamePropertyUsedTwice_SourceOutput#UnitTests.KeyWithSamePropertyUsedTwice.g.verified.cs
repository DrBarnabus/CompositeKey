//HintName: UnitTests.KeyWithSamePropertyUsedTwice.g.cs
// <auto-generated />

#nullable enable annotations
#nullable disable warnings

// Suppress warnings about [Obsolete] member usage in generated code.
#pragma warning disable CS0612, CS0618

using System;
using CompositeKey;

namespace UnitTests
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("CompositeKey.SourceGeneration", "VERSION")]
    public partial record KeyWithSamePropertyUsedTwice : IPrimaryKey<KeyWithSamePropertyUsedTwice>
    {
        public override string ToString()
        {
            return string.Create(73, this, static (destination, state) =>
            {
                int position = 0;

                {
                    if (!((ISpanFormattable)state.Id).TryFormat(destination[position..], out int idCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                    	throw new FormatException();

                    position += idCharsWritten;
                }

                destination[position] = '|';
                position += 1;

                {
                    if (!((ISpanFormattable)state.Id).TryFormat(destination[position..], out int idCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                    	throw new FormatException();

                    position += idCharsWritten;
                }
            });
        }

        public string ToPartitionKeyString()
        {
            return string.Create(73, this, static (destination, state) =>
            {
                int position = 0;

                {
                    if (!((ISpanFormattable)state.Id).TryFormat(destination[position..], out int idCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                    	throw new FormatException();

                    position += idCharsWritten;
                }

                destination[position] = '|';
                position += 1;

                {
                    if (!((ISpanFormattable)state.Id).TryFormat(destination[position..], out int idCharsWritten, "d", global::System.Globalization.CultureInfo.InvariantCulture))
                    	throw new FormatException();

                    position += idCharsWritten;
                }
            });
        }

        public string ToPartitionKeyString(int throughPartIndex, bool includeTrailingDelimiter = true)
        {
            return (throughPartIndex, includeTrailingDelimiter) switch
            {
                (0, false) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{Id:d}"),
                (0, true) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{Id:d}|"),
                (1, false) => string.Create(global::System.Globalization.CultureInfo.InvariantCulture, $"{Id:d}|{Id:d}"),
                _ => throw new InvalidOperationException("Invalid combination of throughPartIndex and includeTrailingDelimiter provided")
            };
        }

        public static KeyWithSamePropertyUsedTwice Parse(string primaryKey)
        {
            ArgumentNullException.ThrowIfNull(primaryKey);
        
            return Parse((ReadOnlySpan<char>)primaryKey);
        }
        
        public static KeyWithSamePropertyUsedTwice Parse(ReadOnlySpan<char> primaryKey)
        {
            if (primaryKey.Length != 73)
                throw new FormatException("Unrecognized format.");
            
            const int expectedPrimaryKeyParts = 2;
            Span<Range> primaryKeyPartRanges = stackalloc Range[expectedPrimaryKeyParts + 1];
            if (primaryKey.Split(primaryKeyPartRanges, '|', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPrimaryKeyParts)
                throw new FormatException("Unrecognized format.");
            
            if (primaryKey[primaryKeyPartRanges[0]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[0]], "d", out var id))
                throw new FormatException("Unrecognized format.");
            
            if (primaryKey[primaryKeyPartRanges[1]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[1]], "d", out var id1))
                throw new FormatException("Unrecognized format.");
            
            if (!id.Equals(id1))
                throw new FormatException("Unrecognized format.");
            
            return new KeyWithSamePropertyUsedTwice(id);
        }

        public static bool TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string? primaryKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out KeyWithSamePropertyUsedTwice? result)
        {
            if (primaryKey is null)
            {
                result = null;
                return false;
            }
        
            return TryParse((ReadOnlySpan<char>)primaryKey, out result);
        }
        
        public static bool TryParse(ReadOnlySpan<char> primaryKey, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out KeyWithSamePropertyUsedTwice? result)
        {
            result = null;
        
            if (primaryKey.Length != 73)
                return false;
            
            const int expectedPrimaryKeyParts = 2;
            Span<Range> primaryKeyPartRanges = stackalloc Range[expectedPrimaryKeyParts + 1];
            if (primaryKey.Split(primaryKeyPartRanges, '|', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) != expectedPrimaryKeyParts)
                return false;
            
            if (primaryKey[primaryKeyPartRanges[0]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[0]], "d", out var id))
                return false;
            
            if (primaryKey[primaryKeyPartRanges[1]].Length != 36 || !Guid.TryParseExact(primaryKey[primaryKeyPartRanges[1]], "d", out var id1))
                return false;
            
            if (!id.Equals(id1))
                return false;
            
            result = new KeyWithSamePropertyUsedTwice(id);
            return true;
        }

        /// <inheritdoc cref="IFormattable.ToString(string?, IFormatProvider?)" />
        string IFormattable.ToString(string? format, IFormatProvider? formatProvider) => ToString();
        
        /// <inheritdoc cref="IParsable{KeyWithSamePropertyUsedTwice}.Parse(string, IFormatProvider?)" />
        static KeyWithSamePropertyUsedTwice IParsable<KeyWithSamePropertyUsedTwice>.Parse(string s, IFormatProvider? provider) => Parse(s);
        
        /// <inheritdoc cref="IParsable{KeyWithSamePropertyUsedTwice}.TryParse(string?, IFormatProvider?, out KeyWithSamePropertyUsedTwice)" />
        static bool IParsable<KeyWithSamePropertyUsedTwice>.TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string? s, IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out KeyWithSamePropertyUsedTwice result) => TryParse(s, out result);
        
        /// <inheritdoc cref="ISpanParsable{KeyWithSamePropertyUsedTwice}.Parse(ReadOnlySpan{char}, IFormatProvider?)" />
        static KeyWithSamePropertyUsedTwice ISpanParsable<KeyWithSamePropertyUsedTwice>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => Parse(s);
        
        /// <inheritdoc cref="ISpanParsable{KeyWithSamePropertyUsedTwice}.TryParse(ReadOnlySpan{char}, IFormatProvider?, out KeyWithSamePropertyUsedTwice)" />
        static bool ISpanParsable<KeyWithSamePropertyUsedTwice>.TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out KeyWithSamePropertyUsedTwice result) => TryParse(s, out result);
    }
}
